package objectEditor.editor;

import objectEditor.model.Movement;
import objectEditor.util.FileUtils;

import javax.swing.*;
import javax.swing.event.ListSelectionEvent;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.io.File;
import java.util.ArrayList;
import java.util.List;
import java.util.Timer;
import java.util.TimerTask;

public class MovementEditorPanel extends BaseEditorPanel<Movement> {
    private static final long serialVersionUID = 1L;

    private JTextField nameField;
    private JTextArea directionsArea;
    private JCheckBox repeatingCheckBox;
    private JCheckBox randomCheckBox;
    private JCheckBox reversibleCheckBox;
    private JSlider moveIntervalSlider;
    private JLabel moveIntervalValueLabel;
    private MovementVisualizer visualizer;
    private Timer animationTimer;
    private boolean isAnimating = false;
    private boolean playInfinitely = false;

    public MovementEditorPanel() {
        super("movement", "Movement");
        initUI();
        loadObjects();
    }

    @Override
    protected void handleListSelectionChanged(ListSelectionEvent e) {
        if (!e.getValueIsAdjusting()) {
            String selectedName = objectListComponent.getSelectedValue();
            if (selectedName != null) {
                Movement movement = objects.get(selectedName);
                if (movement != null) {
                    editObject(movement);
                }
            }
        }
    }

    @Override
    protected void deleteObject() {
        String selectedName = objectListComponent.getSelectedValue();
        if (selectedName != null) {
            int result = JOptionPane.showConfirmDialog(this, 
                    "Are you sure you want to delete " + selectedName + "?", 
                    "Confirm Delete", JOptionPane.YES_NO_OPTION);
            
            if (result == JOptionPane.YES_OPTION) {
                File file = new File("exports/movement/" + selectedName + ".txt");
                if (file.exists() && file.delete()) {
                    int selectedIndex = objectListComponent.getSelectedIndex();
                    objectList.remove(selectedIndex);
                    objects.remove(selectedName);
                    clearForm();
                }
            }
        }
    }

    @Override
    protected void saveObject() {
        Movement movement = getCurrentMovement();
        if (movement != null) {
            String fileName = "exports/movement/" + movement.getName() + ".txt";
            if (FileUtils.saveMovement(movement, fileName)) {
                String oldName = objectListComponent.getSelectedValue();
                if (oldName != null && !oldName.equals(movement.getName())) {
                    int selectedIndex = objectListComponent.getSelectedIndex();
                    objectList.remove(selectedIndex);
                    objects.remove(oldName);
                    objectList.add(selectedIndex, movement.getName());
                    objectListComponent.setSelectedIndex(selectedIndex);
                }
                objects.put(movement.getName(), movement);
                
                currentFile = fileName;
                fileLabel.setText("Current File: " + fileName);
                System.out.println("Movement saved to file: " + fileName);
            }
        }
    }

    private Movement getCurrentMovement() {
        String name = nameField.getText().trim();
        if (name.isEmpty()) {
            JOptionPane.showMessageDialog(this, "Please enter a name.");
            return null;
        }

        Movement movement = new Movement();
        movement.setName(name);
        List<String> directions = new ArrayList<>();
        for (String line : directionsArea.getText().split("\n")) {
            line = line.trim();
            if (!line.isEmpty()) {
                directions.add(line);
            }
        }
        movement.setDirections(directions);
        movement.setRepeating(repeatingCheckBox.isSelected());
        movement.setRandom(randomCheckBox.isSelected());
        movement.setReversible(reversibleCheckBox.isSelected());
        movement.setMoveInterval(moveIntervalSlider.getValue());
        return movement;
    }

    private void clearForm() {
        nameField.setText("");
        directionsArea.setText("");
        repeatingCheckBox.setSelected(false);
        randomCheckBox.setSelected(false);
        reversibleCheckBox.setSelected(false);
        moveIntervalSlider.setValue(1); // Reset to default
        moveIntervalValueLabel.setText("1"); // Update label
        if (visualizer != null) {
            visualizer.setDirections(new ArrayList<>());
            visualizer.repaint();
        }
        currentFile = null;
        fileLabel.setText("Current File: [None]");
    }

    @Override
    protected void initUI() {
        super.initUI();

        JPanel formPanel = new JPanel();
        formPanel.setLayout(new BoxLayout(formPanel, BoxLayout.Y_AXIS));

        // Basic properties
        JPanel basicPanel = new JPanel(new GridBagLayout());
        basicPanel.setBorder(BorderFactory.createTitledBorder("Basic Properties"));
        GridBagConstraints gbc = new GridBagConstraints();
        gbc.insets = new Insets(5, 5, 5, 5);
        gbc.anchor = GridBagConstraints.WEST;

        // Name field
        gbc.gridx = 0;
        gbc.gridy = 0;
        basicPanel.add(new JLabel("Name:"), gbc);

        gbc.gridx = 1;
        gbc.fill = GridBagConstraints.HORIZONTAL;
        gbc.weightx = 1.0;
        nameField = new JTextField(20);
        basicPanel.add(nameField, gbc);

        // Checkboxes
        gbc.gridx = 0;
        gbc.gridy = 1;
        gbc.gridwidth = 2;
        JPanel checkboxPanel = new JPanel(new GridLayout(3, 1, 5, 5));
        repeatingCheckBox = new JCheckBox("Repeating");
        randomCheckBox = new JCheckBox("Random");
        reversibleCheckBox = new JCheckBox("Reversible");
        checkboxPanel.add(repeatingCheckBox);
        checkboxPanel.add(randomCheckBox);
        checkboxPanel.add(reversibleCheckBox);
        basicPanel.add(checkboxPanel, gbc);
        
        // Move interval slider
        gbc.gridx = 0;
        gbc.gridy = 2;
        gbc.gridwidth = 1;
        gbc.fill = GridBagConstraints.NONE;
        gbc.weightx = 0.0;
        basicPanel.add(new JLabel("Move Interval:"), gbc);
        
        gbc.gridx = 1;
        gbc.fill = GridBagConstraints.HORIZONTAL;
        gbc.weightx = 1.0;
        
        JPanel sliderPanel = new JPanel(new BorderLayout(5, 0));
        moveIntervalSlider = new JSlider(JSlider.HORIZONTAL, 1, 10, 1);
        moveIntervalSlider.setMajorTickSpacing(1);
        moveIntervalSlider.setPaintTicks(true);
        moveIntervalSlider.setPaintLabels(true);
        moveIntervalSlider.setSnapToTicks(true);
        
        // Create a tooltip explaining what the slider does
        moveIntervalSlider.setToolTipText(
            "Sets how many turns between movements: 1 = every turn, 2 = every other turn, etc."
        );
        
        // Add a label to show the current value
        moveIntervalValueLabel = new JLabel("1", JLabel.RIGHT);
        moveIntervalValueLabel.setPreferredSize(new Dimension(30, 20));
        
        // Update the label when the slider changes
        moveIntervalSlider.addChangeListener(e -> {
            moveIntervalValueLabel.setText(String.valueOf(moveIntervalSlider.getValue()));
        });
        
        sliderPanel.add(moveIntervalSlider, BorderLayout.CENTER);
        sliderPanel.add(moveIntervalValueLabel, BorderLayout.EAST);
        
        basicPanel.add(sliderPanel, gbc);

        formPanel.add(basicPanel);

        // Create a tabbed pane for the different visual representations
        JTabbedPane tabbedPane = new JTabbedPane();
        
        // Directions panel (standard editor)
        JPanel directionsPanel = createDirectionsPanel();
        tabbedPane.addTab("Directions", directionsPanel);
        
        // Visual Demo tab
        JPanel visualDemoPanel = createVisualDemoPanel();
        tabbedPane.addTab("Visual Demo", visualDemoPanel);
        
        // Visual Demo 2 tab
        JPanel visualDemo2Panel = createVisualDemo2Panel();
        tabbedPane.addTab("Visual Demo 2", visualDemo2Panel);

        formPanel.add(tabbedPane);
        add(formPanel, BorderLayout.CENTER);
    }
    
    /**
     * Creates the directions panel with text area and direction buttons.
     */
    private JPanel createDirectionsPanel() {
        JPanel directionsPanel = new JPanel(new BorderLayout(5, 5));
        directionsPanel.setBorder(BorderFactory.createTitledBorder("Movement Directions"));

        JLabel instructionsLabel = new JLabel(
            "<html>Enter one direction per line using: N, S, E, W, NE, NW, SE, SW</html>"
        );
        directionsPanel.add(instructionsLabel, BorderLayout.NORTH);

        directionsArea = new JTextArea(10, 30);
        directionsArea.setFont(new Font("Monospaced", Font.PLAIN, 12));
        JScrollPane directionsScroll = new JScrollPane(directionsArea);
        directionsPanel.add(directionsScroll, BorderLayout.CENTER);

        // Quick insert buttons
        JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.LEFT));
        String[] directions = {"N", "S", "E", "W", "NE", "NW", "SE", "SW"};
        for (String dir : directions) {
            JButton dirButton = new JButton(dir);
            dirButton.addActionListener(e -> {
                directionsArea.append(dir + "\n");
                updateVisualizer();
            });
            buttonPanel.add(dirButton);
        }
        directionsPanel.add(buttonPanel, BorderLayout.SOUTH);

        // Add preset patterns
        JPanel patternPanel = new JPanel(new FlowLayout(FlowLayout.LEFT));
        patternPanel.setBorder(BorderFactory.createTitledBorder("Preset Patterns"));
        
        String[] patterns = {"Zigzag", "Square", "Circle"};
        for (String pattern : patterns) {
            JButton patternButton = new JButton(pattern);
            patternButton.addActionListener(e -> {
                switch (pattern) {
                    case "Zigzag":
                        directionsArea.setText("E\nNE\nE\nSE");
                        break;
                    case "Square":
                        directionsArea.setText("N\nN\nE\nE\nS\nS\nW\nW");
                        break;
                    case "Circle":
                        directionsArea.setText("N\nNE\nE\nSE\nS\nSW\nW\nNW");
                        break;
                }
                updateVisualizer();
            });
            patternPanel.add(patternButton);
        }
        
        JPanel southPanel = new JPanel(new BorderLayout());
        southPanel.add(buttonPanel, BorderLayout.NORTH);
        southPanel.add(patternPanel, BorderLayout.SOUTH);
        directionsPanel.add(southPanel, BorderLayout.SOUTH);

        return directionsPanel;
    }
    
    /**
     * Creates the visual demo panel with interactive visualization.
     */
    private JPanel createVisualDemoPanel() {
        JPanel panel = new JPanel(new BorderLayout());
        
        // Create visualizer with larger size
        visualizer = new MovementVisualizer();
        visualizer.setPreferredSize(new Dimension(500, 500));
        
        // Wrap the visualizer in a scroll pane to add scrollbars
        JScrollPane visualizerScrollPane = new JScrollPane(visualizer);
        visualizerScrollPane.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_ALWAYS);
        visualizerScrollPane.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);
        visualizerScrollPane.setPreferredSize(new Dimension(350, 350));
        
        panel.add(visualizerScrollPane, BorderLayout.CENTER);
        
        // Add controls
        JPanel controlsContainer = new JPanel(new BorderLayout());
        controlsContainer.setBorder(
            BorderFactory.createTitledBorder("Animation Controls")
        );
        
        // Options panel with checkboxes
        JPanel optionsPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 5, 5));
        JCheckBox infinitePlayCheckBox = new JCheckBox("Play Infinitely");
        infinitePlayCheckBox.setToolTipText("Continue playing past the end of the pattern");
        infinitePlayCheckBox.addActionListener(e -> {
            playInfinitely = infinitePlayCheckBox.isSelected();
            if (isAnimating) {
                // Restart animation with new setting
                stopAnimation();
                startAnimation(playInfinitely);
            }
        });
        optionsPanel.add(infinitePlayCheckBox);
        
        // Zoom controls
        JPanel zoomPanel = new JPanel(new FlowLayout(FlowLayout.RIGHT, 5, 5));
        JButton zoomInButton = new JButton("+");
        zoomInButton.setToolTipText("Zoom In");
        zoomInButton.addActionListener(e -> visualizer.zoomIn());
        
        JButton zoomOutButton = new JButton("-");
        zoomOutButton.setToolTipText("Zoom Out");
        zoomOutButton.addActionListener(e -> visualizer.zoomOut());
        
        JButton resetZoomButton = new JButton("Reset Zoom");
        resetZoomButton.addActionListener(e -> visualizer.resetZoom());
        
        zoomPanel.add(zoomInButton);
        zoomPanel.add(zoomOutButton);
        zoomPanel.add(resetZoomButton);
        
        // Combine options and zoom panel
        JPanel topControlsPanel = new JPanel(new BorderLayout());
        topControlsPanel.add(optionsPanel, BorderLayout.WEST);
        topControlsPanel.add(zoomPanel, BorderLayout.EAST);
        
        // Control buttons panel
        JPanel controlPanel = new JPanel(new FlowLayout(FlowLayout.CENTER, 5, 5));
        
        JButton stepBackButton = new JButton("< Step Back");
        stepBackButton.addActionListener(e -> visualizer.stepBack());
        
        JButton playButton = new JButton("Play");
        playButton.addActionListener(e -> {
            isAnimating = !isAnimating;
            if (isAnimating) {
                playButton.setText("Pause");
                startAnimation(infinitePlayCheckBox.isSelected());
            } else {
                playButton.setText("Play");
                stopAnimation();
            }
        });
        
        JButton stepForwardButton = new JButton("Step Forward >");
        stepForwardButton.addActionListener(e -> visualizer.stepForward());
        
        JButton resetButton = new JButton("Reset");
        resetButton.addActionListener(e -> {
            stopAnimation();
            playButton.setText("Play");
            isAnimating = false;
            visualizer.reset();
        });
        
        controlPanel.add(stepBackButton);
        controlPanel.add(playButton);
        controlPanel.add(stepForwardButton);
        controlPanel.add(resetButton);
        
        JPanel controlsPanel = new JPanel(new BorderLayout());
        controlsPanel.add(topControlsPanel, BorderLayout.NORTH);
        controlsPanel.add(controlPanel, BorderLayout.CENTER);
        
        controlsContainer.add(controlsPanel, BorderLayout.CENTER);
        panel.add(controlsContainer, BorderLayout.SOUTH);
        
        return panel;
    }
    
    /**
     * Creates a simpler visual demo panel with grid visualization.
     */
    private JPanel createVisualDemo2Panel() {
        JPanel panel = new JPanel(new BorderLayout());
        
        // Add explanatory text
        JPanel notePanel = new JPanel(new BorderLayout());
        notePanel.setBorder(BorderFactory.createTitledBorder("Note"));
        
        JTextArea noteArea = new JTextArea(
            "This visualization shows the entire pattern at once.\n" +
            "The grid represents the game world.\n" +
            "Red circle shows the starting position.\n" +
            "Green path shows the movement pattern."
        );
        noteArea.setEditable(false);
        noteArea.setBackground(panel.getBackground());
        noteArea.setLineWrap(true);
        noteArea.setWrapStyleWord(true);
        notePanel.add(noteArea, BorderLayout.CENTER);
        panel.add(notePanel, BorderLayout.NORTH);
        
        // Create a visualization panel that shows the entire pattern
        JPanel visualPanel = new JPanel() {
            private static final long serialVersionUID = 1L;
            private static final int CELL_SIZE = 30;
            private static final int GRID_SIZE = 10;
            
            @Override
            protected void paintComponent(Graphics g) {
                super.paintComponent(g);
                
                Graphics2D g2d = (Graphics2D) g;
                g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
                
                // Draw grid
                g2d.setColor(Color.LIGHT_GRAY);
                for (int i = 0; i <= GRID_SIZE; i++) {
                    g2d.drawLine(0, i * CELL_SIZE, GRID_SIZE * CELL_SIZE, i * CELL_SIZE);
                    g2d.drawLine(i * CELL_SIZE, 0, i * CELL_SIZE, GRID_SIZE * CELL_SIZE);
                }
                
                // Get directions from text area
                List<String> directions = new ArrayList<>();
                for (String line : directionsArea.getText().split("\n")) {
                    if (!line.trim().isEmpty()) {
                        directions.add(line.trim().toUpperCase());
                    }
                }
                
                if (directions.isEmpty()) {
                    g2d.setColor(Color.BLACK);
                    g2d.drawString("Enter directions to visualize the pattern", 20, 20);
                    return;
                }
                
                // Draw starting position
                int centerX = GRID_SIZE / 2;
                int centerY = GRID_SIZE / 2;
                
                g2d.setColor(Color.RED);
                g2d.fillOval(centerX * CELL_SIZE + 5, centerY * CELL_SIZE + 5, 
                            CELL_SIZE - 10, CELL_SIZE - 10);
                
                // Draw the path
                g2d.setColor(Color.GREEN);
                g2d.setStroke(new BasicStroke(3));
                
                int currentX = centerX;
                int currentY = centerY;
                
                for (String dir : directions) {
                    int nextX = currentX;
                    int nextY = currentY;
                    
                    // Calculate next position based on direction
                    switch (dir) {
                        case "N": nextY--; break;
                        case "S": nextY++; break;
                        case "E": nextX++; break;
                        case "W": nextX--; break;
                        case "NE": nextX++; nextY--; break;
                        case "NW": nextX--; nextY--; break;
                        case "SE": nextX++; nextY++; break;
                        case "SW": nextX--; nextY++; break;
                    }
                    
                    // Draw line to next position
                    g2d.drawLine(
                        currentX * CELL_SIZE + CELL_SIZE/2, 
                        currentY * CELL_SIZE + CELL_SIZE/2,
                        nextX * CELL_SIZE + CELL_SIZE/2, 
                        nextY * CELL_SIZE + CELL_SIZE/2
                    );
                    
                    // Update current position
                    currentX = nextX;
                    currentY = nextY;
                }
                
                // Draw final position
                g2d.setColor(Color.BLUE);
                g2d.fillOval(currentX * CELL_SIZE + 5, currentY * CELL_SIZE + 5, 
                            CELL_SIZE - 10, CELL_SIZE - 10);
            }
        };
        
        visualPanel.setPreferredSize(new Dimension(300, 300));
        panel.add(new JScrollPane(visualPanel), BorderLayout.CENTER);
        
        return panel;
    }

    @Override
    protected void loadObjects() {
        objectList.clear();
        objects.clear();

        File folder = new File("exports/movement");
        if (!folder.exists()) {
            folder.mkdirs();
            return;
        }

        File[] files = folder.listFiles((dir, name) -> name.endsWith(".txt"));
        if (files != null) {
            for (File file : files) {
                Movement movement = FileUtils.loadMovement(file.getPath());
                if (movement != null) {
                    objectList.addElement(movement.getName());
                    objects.put(movement.getName(), movement);
                }
            }
        }
    }

    @Override
    protected void editObject(Movement movement) {
        if (movement == null) return;

        nameField.setText(movement.getName());
        repeatingCheckBox.setSelected(movement.isRepeating());
        randomCheckBox.setSelected(movement.isRandom());
        reversibleCheckBox.setSelected(movement.isReversible());
        moveIntervalSlider.setValue(movement.getMoveInterval());
        moveIntervalValueLabel.setText(String.valueOf(movement.getMoveInterval()));

        StringBuilder directions = new StringBuilder();
        for (String dir : movement.getDirections()) {
            if (dir != null && !dir.isEmpty()) {
                directions.append(dir).append("\n");
            }
        }
        directionsArea.setText(directions.toString());
        updateVisualizer();
        
        currentFile = "exports/movement/" + movement.getName() + ".txt";
        fileLabel.setText("Current File: " + currentFile);
    }

    @Override
    protected void createObject() {
        Movement movement = new Movement();
        movement.setName("New Movement");
        movement.setDirections(new ArrayList<>());
        objectList.addElement(movement.getName());
        objects.put(movement.getName(), movement);
        objectListComponent.setSelectedValue(movement.getName(), true);
    }

    @Override
    protected void exportObject() {
        // Not implemented yet
    }

    @Override
    protected void importObject() {
        // Import from file
        JFileChooser fileChooser = new JFileChooser("exports/movement");
        fileChooser.setDialogTitle("Import Movement");
        fileChooser.setFileFilter(new javax.swing.filechooser.FileFilter() {
            @Override
            public boolean accept(File f) {
                return f.isDirectory() || f.getName().endsWith(".txt");
            }

            @Override
            public String getDescription() {
                return "Text Files (*.txt)";
            }
        });

        int result = fileChooser.showOpenDialog(this);
        if (result == JFileChooser.APPROVE_OPTION) {
            File selectedFile = fileChooser.getSelectedFile();
            Movement movement = FileUtils.loadMovement(selectedFile.getPath());
            if (movement != null) {
                // Add to list if it doesn't exist
                if (!objects.containsKey(movement.getName())) {
                    objectList.addElement(movement.getName());
                    objects.put(movement.getName(), movement);
                }
                // Select in list
                objectListComponent.setSelectedValue(movement.getName(), true);
            }
        }
    }

    private void updateVisualizer() {
        List<String> directions = new ArrayList<>();
        for (String line : directionsArea.getText().split("\n")) {
            line = line.trim();
            if (!line.isEmpty()) {
                directions.add(line);
            }
        }
        visualizer.setDirections(directions);
        visualizer.repaint();
        
        // Center the view on the starting point
        SwingUtilities.invokeLater(() -> {
            centerVisualizerOnStartingPoint();
        });
    }
    
    /**
     * Centers the visualizer view on the starting point.
     */
    private void centerVisualizerOnStartingPoint() {
        // Find the scroll pane that contains the visualizer
        Component parent = visualizer.getParent();
        while (parent != null && !(parent instanceof JScrollPane)) {
            parent = parent.getParent();
        }
        
        if (parent instanceof JScrollPane) {
            JScrollPane scrollPane = (JScrollPane) parent;
            JViewport viewport = scrollPane.getViewport();
            
            // Calculate the center position (where the grid center is)
            int gridSize = 20; // This should match the grid size used in visualizer
            int centerX = gridSize / 2 * visualizer.getCellSize() - (viewport.getWidth() / 2) + visualizer.getCellSize() / 2;
            int centerY = gridSize / 2 * visualizer.getCellSize() - (viewport.getHeight() / 2) + visualizer.getCellSize() / 2;
            
            // Ensure we don't scroll beyond bounds
            centerX = Math.max(0, Math.min(centerX, visualizer.getWidth() - viewport.getWidth()));
            centerY = Math.max(0, Math.min(centerY, visualizer.getHeight() - viewport.getHeight()));
            
            // Set the viewport position
            viewport.setViewPosition(new Point(centerX, centerY));
        }
    }
    
    private void startAnimation(boolean infinite) {
        if (animationTimer != null) {
            animationTimer.cancel();
        }
        
        playInfinitely = infinite;
        visualizer.resetTurnCounter(); // Reset the turn counter when starting animation
        
        animationTimer = new Timer();
        animationTimer.scheduleAtFixedRate(new TimerTask() {
            @Override
            public void run() {
                // Get current move interval from the slider
                int moveInterval = moveIntervalSlider.getValue();
                
                // Increment turn counter and check if we should move
                visualizer.incrementTurn();
                
                // Only step forward when the current turn reaches the move interval
                if (visualizer.shouldMove(moveInterval)) {
                    if (playInfinitely) {
                        // If we're at the end but playing infinitely, wrap around to the beginning
                        if (visualizer.isAtEnd()) {
                            visualizer.reset();
                        }
                        visualizer.stepForward();
                    } else {
                        // Only step forward if not at the end
                        if (!visualizer.isAtEnd()) {
                            visualizer.stepForward();
                        } else {
                            // We reached the end, stop the animation
                            SwingUtilities.invokeLater(() -> {
                                stopAnimation();
                                isAnimating = false;
                                // Find the play button and update its text
                                // This is a bit hacky - in a real app, we'd store a reference to the button
                                for (Component comp : SwingUtilities.getWindowAncestor(visualizer).getComponents()) {
                                    if (comp instanceof JButton && ((JButton)comp).getText().equals("Pause")) {
                                        ((JButton)comp).setText("Play");
                                        break;
                                    }
                                }
                            });
                        }
                    }
                } else {
                    // Still update the visualizer to show the turn counter even if we don't move
                    visualizer.repaint();
                }
            }
        }, 500, 500);
    }
    
    private void stopAnimation() {
        if (animationTimer != null) {
            animationTimer.cancel();
            animationTimer = null;
        }
    }

    private class MovementVisualizer extends JPanel {
        private static final long serialVersionUID = 1L;
        private static final int DEFAULT_CELL_SIZE = 30;
        private int cellSize = DEFAULT_CELL_SIZE;
        private List<String> directions = new ArrayList<>();
        private List<Point> pathPoints = new ArrayList<>();
        private int currentStep = 0;
        private int currentTurn = 0; // Tracks the current turn within the move interval

        public MovementVisualizer() {
            setBackground(Color.WHITE);
        }

        public void setDirections(List<String> directions) {
            this.directions = directions;
            calculatePath();
            currentStep = 0;
        }
        
        public boolean isAtEnd() {
            return currentStep >= pathPoints.size() - 1;
        }
        
        public void stepForward() {
            if (!directions.isEmpty() && (currentStep < pathPoints.size() - 1 || playInfinitely)) {
                if (playInfinitely && currentStep >= pathPoints.size() - 1) {
                    // In infinite mode, loop back to the beginning
                    currentStep = 0;
                } else {
                    currentStep++;
                }
                repaint();
            }
        }
        
        public void stepBack() {
            if (currentStep > 0) {
                currentStep--;
                repaint();
            }
        }
        
        public void reset() {
            currentStep = 0;
            repaint();
        }
        
        public void zoomIn() {
            cellSize += 5;
            recalculateSize();
            repaint();
        }
        
        public void zoomOut() {
            if (cellSize > 10) {
                cellSize -= 5;
                recalculateSize();
                repaint();
            }
        }
        
        public void resetZoom() {
            cellSize = DEFAULT_CELL_SIZE;
            recalculateSize();
            repaint();
        }
        
        public int getCellSize() {
            return cellSize;
        }
        
        private void recalculateSize() {
            // Calculate needed size based on the path points and cell size
            int gridSize = 20; // Default size
            setPreferredSize(new Dimension(gridSize * cellSize, gridSize * cellSize));
            revalidate();
        }
        
        private void calculatePath() {
            pathPoints.clear();
            
            if (directions.isEmpty()) {
                return;
            }
            
            // Start at the center
            int gridWidth = 20; // Using a fixed grid size for calculation
            int gridHeight = 20;
            Point currentPos = new Point(gridWidth / 2, gridHeight / 2);
            pathPoints.add(new Point(currentPos));
            
            // Calculate path for all directions
            for (String dir : directions) {
                Point nextPoint = calculateNextPosition(currentPos, dir);
                pathPoints.add(nextPoint);
                currentPos = nextPoint;
            }
            
            // Ensure the panel is large enough to show the entire path
            recalculateSize();
        }
        
        private Point calculateNextPosition(Point currentPos, String direction) {
            Point nextPos = new Point(currentPos);
            
            switch (direction.toUpperCase()) {
                case "N": nextPos.y--; break;
                case "S": nextPos.y++; break;
                case "E": nextPos.x++; break;
                case "W": nextPos.x--; break;
                case "NE": nextPos.x++; nextPos.y--; break;
                case "NW": nextPos.x--; nextPos.y--; break;
                case "SE": nextPos.x++; nextPos.y++; break;
                case "SW": nextPos.x--; nextPos.y++; break;
            }
            
            return nextPos;
        }

        @Override
        protected void paintComponent(Graphics g) {
            super.paintComponent(g);
            Graphics2D g2d = (Graphics2D) g;
            g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);

            // Draw grid
            g2d.setColor(Color.LIGHT_GRAY);
            for (int x = 0; x < getWidth(); x += cellSize) {
                g2d.drawLine(x, 0, x, getHeight());
            }
            for (int y = 0; y < getHeight(); y += cellSize) {
                g2d.drawLine(0, y, getWidth(), y);
            }
            
            // Draw coordinate system reference
            g2d.setColor(Color.BLACK);
            g2d.drawString("(0,0)", 5, 15);
            
            // Draw step counter and play status
            g2d.setColor(Color.BLACK);
            String playStatus = playInfinitely ? "Mode: Infinite Loop" : "Mode: Play Once";
            g2d.drawString("Step: " + currentStep + " / " + (pathPoints.size() > 0 ? pathPoints.size() - 1 : 0) + 
                           "   " + playStatus, 10, 30);
            
            // Display move interval
            g2d.drawString("Move Interval: Every " + moveIntervalSlider.getValue() + 
                          (moveIntervalSlider.getValue() == 1 ? " turn" : " turns"), 10, 50);

            if (directions.isEmpty()) return;

            // Draw path
            g2d.setColor(Color.BLUE);
            g2d.setStroke(new BasicStroke(2));
            
            if (pathPoints.size() > 1) {
                // Draw completed path segments in blue
                for (int i = 0; i < Math.min(currentStep, pathPoints.size() - 1); i++) {
                    Point p1 = pathPoints.get(i);
                    Point p2 = pathPoints.get(i + 1);
                    
                    int x1 = p1.x * cellSize + cellSize / 2;
                    int y1 = p1.y * cellSize + cellSize / 2;
                    int x2 = p2.x * cellSize + cellSize / 2;
                    int y2 = p2.y * cellSize + cellSize / 2;
                    
                    g2d.drawLine(x1, y1, x2, y2);
                }
                
                // Draw future path segments as dashed gray
                if (currentStep < pathPoints.size() - 1) {
                    g2d.setColor(Color.LIGHT_GRAY);
                    float[] dash = {5.0f};
                    g2d.setStroke(new BasicStroke(1, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 10.0f, dash, 0.0f));
                    
                    for (int i = currentStep; i < pathPoints.size() - 1; i++) {
                        Point p1 = pathPoints.get(i);
                        Point p2 = pathPoints.get(i + 1);
                        
                        int x1 = p1.x * cellSize + cellSize / 2;
                        int y1 = p1.y * cellSize + cellSize / 2;
                        int x2 = p2.x * cellSize + cellSize / 2;
                        int y2 = p2.y * cellSize + cellSize / 2;
                        
                        g2d.drawLine(x1, y1, x2, y2);
                    }
                }
            }

            // Draw starting point
            if (pathPoints.size() > 0) {
                Point startPoint = pathPoints.get(0);
                g2d.setColor(Color.GREEN);
                int startX = startPoint.x * cellSize + cellSize / 2 - 5;
                int startY = startPoint.y * cellSize + cellSize / 2 - 5;
                g2d.fillOval(startX, startY, 10, 10);
                g2d.setColor(Color.BLACK);
                g2d.drawOval(startX, startY, 10, 10);
            }

            // Draw current position
            if (pathPoints.size() > currentStep) {
                Point currentPoint = pathPoints.get(currentStep);
                g2d.setColor(Color.RED);
                int currentX = currentPoint.x * cellSize + cellSize / 2 - 5;
                int currentY = currentPoint.y * cellSize + cellSize / 2 - 5;
                g2d.fillOval(currentX, currentY, 10, 10);
                g2d.setColor(Color.BLACK);
                g2d.drawOval(currentX, currentY, 10, 10);
            }
        }
    }
}
